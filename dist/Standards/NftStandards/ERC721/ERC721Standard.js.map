{"version":3,"file":"ERC721Standard.js","sourceRoot":"","sources":["../../../../src/Standards/NftStandards/ERC721/ERC721Standard.ts"],"names":[],"mappings":"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","sourcesContent":["import { abiERC721 } from '@metamask/metamask-eth-abis';\nimport { Contract } from '@ethersproject/contracts';\nimport {\n  timeoutFetch,\n  ERC721_INTERFACE_ID,\n  ERC721_METADATA_INTERFACE_ID,\n  ERC721_ENUMERABLE_INTERFACE_ID,\n  ERC721,\n} from '@metamask/controller-utils';\nimport { Web3Provider } from '@ethersproject/providers';\nimport { getFormattedIpfsUrl } from '../../../assetsUtil';\n\nexport class ERC721Standard {\n  private provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Query if contract implements ERC721Metadata interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721Metadata interface.\n   */\n  contractSupportsMetadataInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC721_METADATA_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC721Enumerable interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721Enumerable interface.\n   */\n  contractSupportsEnumerableInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC721_ENUMERABLE_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC721 interface.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC721 interface.\n   */\n  contractSupportsBase721Interface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(address, ERC721_INTERFACE_ID);\n  };\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param selectedAddress - Current account public address.\n   * @param index - An NFT counter less than `balanceOf(selectedAddress)`.\n   * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.\n   */\n  getNftTokenId = async (\n    address: string,\n    selectedAddress: string,\n    index: number,\n  ): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.tokenOfOwnerByIndex(selectedAddress, index);\n  };\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  getTokenURI = async (address: string, tokenId: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    const supportsMetadata = await this.contractSupportsMetadataInterface(\n      address,\n    );\n    if (!supportsMetadata) {\n      throw new Error('Contract does not support ERC721 metadata interface.');\n    }\n    return contract.tokenURI(tokenId);\n  };\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to the 'name'.\n   */\n  getAssetName = async (address: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.name();\n  };\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  getAssetSymbol = async (address: string): Promise<string> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.symbol();\n  };\n\n  /**\n   * Query for owner for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to the owner address.\n   */\n  async getOwnerOf(address: string, tokenId: string): Promise<string> {\n    const contract = new Contract(address, abiERC721, this.provider);\n    return contract.ownerOf(tokenId);\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param interfaceId - Interface identifier.\n   * @returns Promise resolving to whether the contract implements `interfaceID`.\n   */\n  private contractSupportsInterface = async (\n    address: string,\n    interfaceId: string,\n  ): Promise<boolean> => {\n    const contract = new Contract(address, abiERC721, this.provider);\n    try {\n      return await contract.supportsInterface(interfaceId);\n    } catch (err: any) {\n      // Mirror previous implementation\n      if (err.message.includes('call revert exception')) {\n        return false;\n      }\n      throw err;\n    }\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param ipfsGateway - The user's preferred IPFS gateway.\n   * @param tokenId - tokenId of a given token in the contract.\n   * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.\n   */\n  getDetails = async (\n    address: string,\n    ipfsGateway: string,\n    tokenId?: string,\n  ): Promise<{\n    standard: string;\n    tokenURI: string | undefined;\n    symbol: string | undefined;\n    name: string | undefined;\n    image: string | undefined;\n  }> => {\n    const isERC721 = await this.contractSupportsBase721Interface(address);\n    if (!isERC721) {\n      throw new Error(\"This isn't a valid ERC721 contract\");\n    }\n\n    let tokenURI, image, symbol, name;\n\n    // TODO upgrade to use Promise.allSettled for name/symbol when we can refactor to use es2020 in tsconfig\n    try {\n      symbol = await this.getAssetSymbol(address);\n    } catch {\n      // ignore\n    }\n\n    try {\n      name = await this.getAssetName(address);\n    } catch {\n      // ignore\n    }\n\n    if (tokenId) {\n      try {\n        tokenURI = await this.getTokenURI(address, tokenId);\n        if (tokenURI.startsWith('ipfs://')) {\n          tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, true);\n        }\n\n        const response = await timeoutFetch(tokenURI);\n        const object = await response.json();\n        image = object?.image;\n        if (image?.startsWith('ipfs://')) {\n          image = getFormattedIpfsUrl(ipfsGateway, image, true);\n        }\n      } catch {\n        // ignore\n      }\n    }\n\n    return {\n      standard: ERC721,\n      tokenURI,\n      symbol,\n      name,\n      image,\n    };\n  };\n}\n"]}