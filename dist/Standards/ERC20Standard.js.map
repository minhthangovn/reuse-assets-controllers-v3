{"version":3,"file":"ERC20Standard.js","sourceRoot":"","sources":["../../src/Standards/ERC20Standard.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,wDAAoD;AACpD,mEAAuD;AACvD,qDAA6C;AAC7C,4CAA8C;AAE9C,iEAAmD;AACnD,8CAAoD;AAEpD,MAAa,aAAa;IAGxB,YAAY,QAAsB;QAChC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC3B,CAAC;IAED;;;;;;OAMG;IACG,YAAY,CAAC,OAAe,EAAE,eAAuB;;YACzD,MAAM,QAAQ,GAAG,IAAI,oBAAQ,CAAC,OAAO,EAAE,4BAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;YAChE,MAAM,OAAO,GAAG,MAAM,QAAQ,CAAC,SAAS,CAAC,eAAe,CAAC,CAAC;YAC1D,OAAO,IAAA,gCAAmB,EAAC,OAAO,CAAC,CAAC;QACtC,CAAC;KAAA;IAED;;;;;OAKG;IACG,gBAAgB,CAAC,OAAe;;YACpC,MAAM,QAAQ,GAAG,IAAI,oBAAQ,CAAC,OAAO,EAAE,4BAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;YAChE,IAAI;gBACF,MAAM,QAAQ,GAAG,MAAM,QAAQ,CAAC,QAAQ,EAAE,CAAC;gBAC3C,OAAO,QAAQ,CAAC,QAAQ,EAAE,CAAC;aAC5B;YAAC,OAAO,GAAQ,EAAE;gBACjB,iCAAiC;gBACjC,IAAI,GAAG,CAAC,OAAO,CAAC,QAAQ,CAAC,uBAAuB,CAAC,EAAE;oBACjD,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;iBACnD;gBACD,MAAM,GAAG,CAAC;aACX;QACH,CAAC;KAAA;IAED;;;;;OAKG;IACG,cAAc,CAAC,OAAe;;YAClC,mCAAmC;YACnC,MAAM,OAAO,GAAG,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,YAAY,EAAE,CAAC;YACpD,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAEjD,MAAM,QAAQ,GAAG,IAAI,cAAQ,EAAE,CAAC;YAEhC,kDAAkD;YAClD,IAAI;gBACF,MAAM,OAAO,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;gBACvD,IAAI,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,IAAG,CAAC,EAAE;oBACvB,OAAO,OAAO,CAAC;iBAChB;aACF;YAAC,WAAM;gBACN,eAAe;aAChB;YAED,iDAAiD;YACjD,IAAI;gBACF,MAAM,IAAI,GAAG,IAAA,wBAAM,EAAC,MAAM,CAAC,CAAC;gBAC5B,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;oBACnB,OAAO,IAAI,CAAC;iBACb;aACF;YAAC,WAAM;gBACN,eAAe;aAChB;YAED,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;QAClD,CAAC;KAAA;IAED;;;;;;OAMG;IACG,UAAU,CACd,OAAe,EACf,WAAoB;;YAOpB,MAAM,CAAC,QAAQ,EAAE,MAAM,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC;gBAC3C,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC;gBAC9B,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC;aAC7B,CAAC,CAAC;YACH,IAAI,OAAO,CAAC;YACZ,IAAI,WAAW,EAAE;gBACf,OAAO,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;aACzD;YACD,OAAO;gBACL,QAAQ;gBACR,MAAM;gBACN,OAAO;gBACP,QAAQ,EAAE,wBAAK;aAChB,CAAC;QACJ,CAAC;KAAA;CACF;AA3GD,sCA2GC","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { abiERC20 } from '@metamask/metamask-eth-abis';\nimport { BN, toUtf8 } from 'ethereumjs-util';\nimport { AbiCoder } from '@ethersproject/abi';\nimport { Web3Provider } from '@ethersproject/providers';\nimport { ERC20 } from '@metamask/controller-utils';\nimport { ethersBigNumberToBN } from '../assetsUtil';\n\nexport class ERC20Standard {\n  private provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Get balance or count for current account on specific asset contract.\n   *\n   * @param address - Asset ERC20 contract address.\n   * @param selectedAddress - Current account public address.\n   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.\n   */\n  async getBalanceOf(address: string, selectedAddress: string): Promise<BN> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    const balance = await contract.balanceOf(selectedAddress);\n    return ethersBigNumberToBN(balance);\n  }\n\n  /**\n   * Query for the decimals for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract string.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getTokenDecimals(address: string): Promise<string> {\n    const contract = new Contract(address, abiERC20, this.provider);\n    try {\n      const decimals = await contract.decimals();\n      return decimals.toString();\n    } catch (err: any) {\n      // Mirror previous implementation\n      if (err.message.includes('call revert exception')) {\n        throw new Error('Failed to parse token decimals');\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Query for symbol for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  async getTokenSymbol(address: string): Promise<string> {\n    // Signature for calling `symbol()`\n    const payload = { to: address, data: '0x95d89b41' };\n    const result = await this.provider.call(payload);\n\n    const abiCoder = new AbiCoder();\n\n    // Parse as string - treat empty string as failure\n    try {\n      const decoded = abiCoder.decode(['string'], result)[0];\n      if (decoded?.length > 0) {\n        return decoded;\n      }\n    } catch {\n      // Ignore error\n    }\n\n    // Parse as bytes - treat empty string as failure\n    try {\n      const utf8 = toUtf8(result);\n      if (utf8.length > 0) {\n        return utf8;\n      }\n    } catch {\n      // Ignore error\n    }\n\n    throw new Error('Failed to parse token symbol');\n  }\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param userAddress - The public address for the currently active user's account.\n   * @returns Promise resolving an object containing the standard, decimals, symbol and balance of the given contract/userAddress pair.\n   */\n  async getDetails(\n    address: string,\n    userAddress?: string,\n  ): Promise<{\n    standard: string;\n    symbol: string | undefined;\n    decimals: string | undefined;\n    balance: BN | undefined;\n  }> {\n    const [decimals, symbol] = await Promise.all([\n      this.getTokenDecimals(address),\n      this.getTokenSymbol(address),\n    ]);\n    let balance;\n    if (userAddress) {\n      balance = await this.getBalanceOf(address, userAddress);\n    }\n    return {\n      decimals,\n      symbol,\n      balance,\n      standard: ERC20,\n    };\n  }\n}\n"]}